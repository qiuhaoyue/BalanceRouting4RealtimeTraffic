Title         : 实时路况计算系统
Author        : 张禹

Logo          : True
Email         : zhangrain911@163.com


Doc class     : [10pt]article


[TITLE]


[TOC]


# 1. 系统框架图 {-}



![framework]

[framework]: images/framework.jpg "framework" { width:auto; max-width:90% }

黄色部分为线程的一次执行。


# 2. 模块说明 {-}


## 2.1 Dispatcher: {-}
将输入的GPS点按照suid分配到具体的子节点上进行计算，本地需要维护一张子节点与suid范围
的映射表。暂时不考虑

  输入：原始GPS流(suid, utc, lat, lon, head, ostdesc)(省略某些不用的属性)
  
  输出：按suid分割的GPS流，并简单丢弃定位无效的点
  
## 2.2 出租车队列： {-}
GPS点按照suid放入内存，将定位无效的点丢弃。当某一队列中的GPS点数量超过阈值或时间超过阈值时，
从线程池获取资源，建立线程将队列中的点送入预处理模块。为保持道路匹配的精度，队列中保留最近的2-3个点（待确认）。
  
  
  输入：GPS流
  
  输出：分割后的单辆出租车GPS点序列(GPS1, GPS2, GPS3...)，有长度及时间限制。

## 2.3 线程池： {-}
使用java自带的FixedThreadPool，可能改为CachedThreadPool，需要测试确认哪种更适合。黄色部分都属于线程。
  
  
  输入：出租车suid以及该辆出租车的GPS点序列。
  
  输出：无输出。将处理完毕的GPS点写入GPS数据库。
  
## 2.4 预处理： {-}
输入同一辆出租车的点序列，根据距离与时间间隔（可修改）插入点的长暂停标记。以后可能会添加轨迹相关的筛选。
  
  
  输入：单辆出租车的GPS点序列。
  
  输出：单辆出租车的GPS点序列，每个GPS点添加属性stop。
  
## 2.5 HMMM道路匹配： {-}
输入带长暂停标记的出租车点序列，使用[在线的HMMM算法]进行道路匹配。如果点序列数量大于阈值，执行Sequence匹配(精确度高，但有输出延时)，
  否则执行online匹配(精确度低，当前点不考虑后面点的匹配情况，无输出延时)。输出的GPS点带有
  Gid，Edge_offset,route三个字段，分别表示将这个点匹配的道路id，偏移以及这个点的前一个点到当前sample通过的路径。
   
   
  输入：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop)序列
  
  输出：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route)序列

## 2.6 后处理： {-}
输入带长暂停以及道路标记的点序列，对匹配完成的点序列进一步处理，对当前点标记上一个点所在的道路以及时间间隔。
  
  
  输入：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route)序列
  
  输出：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route, interval, pre_gid, pre_offset)序列


## 2.7 路况片段计算模块： {-}
根据车辆点在道路匹配后获得的路由信息，计算其经过的道路的路况。
  
  
  输入：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route, interval, pre_gid, pre_offset)序列
  
  输出：局部，不完整的路况信息，(seq, gid, next_gid, time, percent, interval, tmstp, suid, utc, start_pos)。
  seq为时间段的序号。

## 2.8 更新汇总模块： {-}
为防止频繁写数据库带来的时间消耗，对插入的数据信息进行汇总，统一写入。
  
  
  输入：线程对应的一段GPS序列探测到的路况(seq, gid, next_gid, time, percent, interval, tmstp, suid, utc, start_pos)
  
  输出：当更新记录数大于某一阈值或时间大于某一阈值时执行写入(避免数据过时)。
  
## 2.9 GPS备份： {-}
为实验需求，对处理完的GPS进行备份。
    
输入：处理完毕的GPS流(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route, interval, pre_gid, ore_offset)
    
输出：写入GPS数据库。
    

## 2.10 路况聚合模块： {-}
对数据库中某一时间段的路况片段进行聚合，计算(道路A,道路B)的通过时间,以及某一条道路的通过时间(对于没有结果的道路,使用同等级道路的平均值作为缺省值)
每间隔某一段时间后执行(例如5分钟，具体根据GPS数据处理延时)，若延迟低，可以不分段，只记录当前路况。

输入：指定时间(utc)内的路况片段

输出：指定时间内的总路况，道路的路况包括2种，next_gid不为null的是指定下一条路的travel time，对于不同的next_gid速度不同，
  next_gid为null的是一条路的总的路况，该记录唯一。将(gid, next_gid, reference, time, average_speed, class_id, name, length, to_cost, reverse_cost)
  信息写入traffic数据库。

# 3. 核心算法 {-}
## 3.1 长暂停标记： {-}

![label_stop]

[label_stop]: images/label_stop.jpg "label_stop" { width:auto; max-width:90% }


设定一个距离阈值，时间阈值。

      for point in GPS sequence:
        以当前点为基准，选出在该点之前且距离在阈值内的所有点作为集合A；
        for point in A:
          求出集合A中的点与当前点的时间间隔；
        将时间间隔大于阈值的点标记为长暂停；
 
## 3.2 轨迹预处理: {-}
暂不考虑
        
## 3.3 道路匹配： {-}
算法参考论文：“Online map-matching based on Hidden Markov model for real-time traffic sensing applications”

  实现：[在线的HMMM算法]，在这基础上可能会进一步修改。
 
## 3.4 路况计算： {-}


![路况更新模块]

[路况更新模块]: images/update_traffic.jpg "update_traffic" { width:auto; max-width:90% }

    如图所示，可按suid划分后并行处理。
    

  
    1.先计算从每个点及其与上一个点之间的路由信息获取到的路况；

      for each point in GPS database:
        for each road in route://遍历出租车从上一个点到当前点经过的所有道路
          计算出租车在道路上的覆盖率;
          根据覆盖率计算在当前道路上消耗的时间，具体公式为覆盖率*当前道路长度/当前道路到下一条道路的速度(迭代);
          将算得的时间累加到totaltime;
        for each road in route that has coverage://所有成功算出覆盖率的道路，可能有路段出现异常
          计算当前道路到下一个路段的通过时间，具体公式为：
          当前点的间隔(即与上一个gps点的时间差)*道路长度/当前道路到下一条道路的速度*覆盖率/totaltime；
    
  
    2.将所有gps点挖掘出的路况进行聚合；
 

# 4. 相关工作 {-}

1. Real-time freeway traffic state estimation based on extended Kalman filter: a general approach

  对于高速公路上的路况计算采用模型(extended Kalman filter)的方式估计各类变量，但高速公路的情况较为简单，该方法在城市中不适用。

2. Real-Time Traffic Volume Estimation with Fuzzy Linear Regression
  
  同样是基于模型，对交通流量进行预测，较为精确，但模型的输入是道路的流量与拥挤程度，对于浮动车来说无法直接获取到这2种信息。

3. Study on Vehicle Navigation System with Real-time Traffic Information

  利用探测车来探测，由中心节点进行汇总，计算路况，并提供导航。具体如何计算路况或导航并没有介绍。除了静态路段外，根据路况以及道路的属性进行动态的道路分段(可能跨越多个物理道路)。实验也是在北京做的。

4. Traffic Estimation And Prediction Based On Real Time Floating Car Data

  基于600，000辆私家车gps数据的实时路况系统，3分钟更新一次，通过网页可以获取，主要是针对意大利的摩托车道和一些主干道。

  道路匹配(经纬度和方向)->计算路由->计算路由道路上的时间，与我们的计算过程类似，但并没有给出具体实现，最后提供了几种估计未来路况的方法。

5. Real-time urban traffic monitoring with global positioning system-equipped vehicles

  使用point-to-curve道路匹配算法(做了改进)。使用eSMS（estimated space mean speed）并将其转换为更合理的路况量度

  1.道路匹配后的预处理：存储gps点，相同路段的点存在同一个数据结构中，对于每一个数据结构(对应一个路段),计算其第一个点到每个点的曲线距离，并作为gps点的一个属性存储。
  
  2.求eSMS：将某一路段上的点的速度曲线近似为2次方程。但计算路况时只取其平滑的部分(对加速度做限制)作为参考，并计算平均速度。最后对所有车的速度求eSMS。
  
  3.将eSMS转化为一个更合理的smooth index(0,1之间，0表示拥堵，1表示畅通)
实验：上海6000辆出租车。该方法将状态为空车的出租车数据丢弃，每4分钟算一次，没有考虑不同道路之间的路由。通过视频来人工判断路况，分5个等级，时间花费也较低

6. (1)Real-time Urban Traffic Sensing with GPS Equipped
Probe Vehicles (2) Scaling the Real-time Traffic Sensing with GPS Equipped Probe Vehicles

  在storm上部署实时路况探测，同样丢弃了空车的数据点，使用HMMM进行道路匹配，Fuzzy C-Means Clustering algorithm来去除一些不正常的行驶行为对路况的影响，将车辆探测到的速度分为2组，高速与低速，只有规模大的那一组会被采用。道路匹配是最耗时的部分

7. Traffic State Detection with Floating Car Data in Road Networks

  考虑了trafic center和出租车的信息交互过程。最小化信息交互次数，出租车在本地判断是否将该车在某一道路上的travel time（进入道路与离开道路的时间差）上传至中心(若travel time与本地已知的time差距大于某一阈值，则上传)。
出租车在离开道路后上传路况，中心需要对时间做修改，比如10：45上传出租车通过道路A需要30分钟，那么该路况同时也是10：15得路况。

  对路况做预测，并做动态导航
以预测为主，出租车的数据用于纠正历史信息，所以始终是有延迟的
[在线的HMMM算法]: https://github.com/bmwcarit/barefoot


