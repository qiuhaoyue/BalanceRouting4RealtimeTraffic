Title         : 实时路况计算系统
Author        : 张禹

Logo          : True
Email         : zhangrain911@163.com


Doc class     : [10pt]article


[TITLE]


[TOC]


# 1. 系统框架图 {-}




![new_framework]

黄色部分为线程的一次执行,棕红色为路况结果。

[new_framework]: images/new_framework.jpg "new_framework" { width:auto; max-width:90% }


# 2. 模块说明 {-}


## 2.1 Dispatcher: {-}
将输入的GPS点按照suid分配到具体的子节点上进行计算，本地需要维护一张子节点与suid范围
的映射表。暂时不考虑。

  输入：原始GPS流(suid, utc, lat, lon, head, ostdesc)(省略某些不用的属性)
  
  输出：按suid分割的GPS流，并简单丢弃定位无效的点，GPS点按照suid存入内存队列。
  
## 2.2 OHMMM道路匹配出租车队列： {-}
在线的HMMM匹配，有一定延迟，目前设定的匹配窗口最大值为5。输出的GPS点带有
  Gid，Edge_offset,route三个字段，分别表示将这个点匹配的道路id，偏移以及这个点的前一个点到当前sample通过的路径。
  
  
  输入：GPS点
  
  输出：输出添加了Gid, Edge_offset, route 3个属性的GPS点。

  
## 2.3 轨迹切割： {-}
判断当前队列中的点是否满足切割条件，当车辆行驶的路段发生改变或车辆处于长暂停时进行轨迹切割
  
  
  输入：队列中的gps点信息。
  
  输出：满足切割条件时，输出GPS序列，否则输出当前的单个GPS点。
  
## 2.4 线程池： {-}
使用java自带的FixedThreadPool，可能改为CachedThreadPool，需要测试确认哪种更适合。黄色部分都属于线程。
  
  
  输入：出租车suid以及该辆出租车的GPS点序列。
  
  输出：启动一个线程，根据一个GPS序列进行路况计算。
  
## 2.5 轨迹预处理： {-}
输入同一辆出租车的点序列，根据距离与时间间隔（可修改）插入点的长暂停标记。以后可能会添加轨迹相关的筛选。
  
  
  输入：单辆出租车的GPS点序列。
  
  输出：单辆出租车的GPS点序列，每个GPS点添加属性stop。
  
## 2.6 实时路况计算模块： {-}
根据新获取的GPS点计算路况。如果与上一个GPS点在同一道路上则直接更新该道路路况，如果上一个点不在
同一道路上，则需要先计算与上一个点之间的路由，并更新路由上所有道路的路况
  
  
  输入：单个GPS点。
  
  输出：更新内存中的实时路况。
  
## 2.7 HMMM道路匹配： {-}
输入带长暂停标记的出租车点序列，使用[在线的HMMM算法]进行道路匹配。执行Sequence匹配(精确度高，但有输出延时)，
输出的GPS点属性与OHMMM相同。
   
   
  输入：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop)序列
  
  输出：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route)序列

## 2.8 后处理： {-}
输入带长暂停以及道路标记的点序列，对匹配完成的点序列进一步处理，对当前点标记上一个点所在的道路以及时间间隔。
  
  
  输入：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route)序列
  
  输出：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route, interval, pre_gid, pre_offset)序列


## 2.9 路况片段计算模块： {-}
根据车辆点在道路匹配后获得的路由信息，计算其经过的道路的路况。遍历序列中的点，如果匹配的道路与OHMMM相同，则只根据算出的路况的
不同对该道路的路况做修正，如果匹配的路段不同，则需要在消除OHMMM匹配错误对路况的影响后再做修正。
  
  
  输入：单辆出租车的GPS点(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route, interval, pre_gid, pre_offset)序列
  
  输出：局部，不完整的路况信息，(seq, gid, next_gid, time, percent, interval, tmstp, suid, utc, start_pos)。
  seq为时间段的序号。并对内存中的路况做反馈

## 2.10 更新汇总模块： {-}
为防止频繁写数据库带来的时间消耗，对插入的数据信息进行汇总，统一写入。
  
  
## 2.11 GPS备份： {-}
为实验需求，对处理完的GPS进行备份。
    
输入：处理完毕的GPS流(suid, utc, lat, lon, head, ostdesc, stop, Gid, Edge_offset, route, interval, pre_gid, ore_offset)
    
输出：写入GPS数据库。
    

## 2.12 路况聚合模块： {-}
对某一时间段的路况片段进行聚合，计算(道路A,道路B)的通过时间,以及某一条道路的通过时间(对于没有结果的道路,使用同等级道路的平均值作为缺省值)
每间隔某一段时间后执行(例如5分钟，具体根据GPS数据处理延时)，若延迟低，可以不分段，只记录当前路况。

输入：指定时间(utc)内的路况片段

输出：指定时间内的总路况，道路的路况包括2种，next_gid不为null的是指定下一条路的travel time，对于不同的next_gid速度不同，
  next_gid为null的是一条路的总的路况，该记录唯一。将(gid, next_gid, reference, time, average_speed, class_id, name, length, to_cost, reverse_cost)
  信息写入traffic数据库。

# 3. 核心算法 {-}
## 3.1 长暂停标记： {-}

![label_stop]

[label_stop]: images/label_stop.jpg "label_stop" { width:auto; max-width:90% }


设定一个距离阈值，时间阈值。

      for point in GPS sequence:
        以当前点为基准，选出在该点之前且距离在阈值内的所有点作为集合A；
        for point in A:
          求出集合A中的点与当前点的时间间隔；
        将时间间隔大于阈值的点标记为长暂停；
 
## 3.2 轨迹预处理: {-}
暂不考虑
        
## 3.3 道路匹配： {-}
算法参考论文：“Online map-matching based on Hidden Markov model for real-time traffic sensing applications”

  实现：[在线的HMMM算法]，在这基础上可能会进一步修改。
 
## 3.4 路况计算： {-}


![路况更新模块]

[路况更新模块]: images/update_traffic.jpg "update_traffic" { width:auto; max-width:90% }

    如图所示，可按suid划分后并行处理。
    

  
    1.先计算从每个点及其与上一个点之间的路由信息获取到的路况；

      for each point in GPS database:
        for each road in route://遍历出租车从上一个点到当前点经过的所有道路
          计算出租车在道路上的覆盖率;
          根据覆盖率计算在当前道路上消耗的时间，具体公式为覆盖率*当前道路长度/当前道路到下一条道路的速度(迭代);
          将算得的时间累加到totaltime;
        for each road in route that has coverage://所有成功算出覆盖率的道路，可能有路段出现异常
          计算当前道路到下一个路段的通过时间，具体公式为：
          当前点的间隔(即与上一个gps点的时间差)*道路长度/当前道路到下一条道路的速度*覆盖率/totaltime；
    
  
    2.将所有gps点挖掘出的路况进行聚合；
 

# 4. 相关工作调研 {-}

1. Real-time freeway traffic state estimation based on extended Kalman filter: a general approach

  对于高速公路上的路况计算采用模型(extended Kalman filter)的方式估计各类变量，但高速公路的情况较为简单，该方法在城市中不适用。

2. Real-Time Traffic Volume Estimation with Fuzzy Linear Regression
  
  同样是基于模型，对交通流量进行预测，较为精确，但模型的输入是道路的流量与拥挤程度，对于浮动车来说无法直接获取到这2种信息。

3. Study on Vehicle Navigation System with Real-time Traffic Information

  利用探测车来探测，由中心节点进行汇总，计算路况，并提供导航。具体如何计算路况或导航并没有介绍。除了静态路段外，根据路况以及道路的属性进行动态的道路分段(可能跨越多个物理道路)。实验也是在北京做的。

4. Traffic Estimation And Prediction Based On Real Time Floating Car Data

  基于600，000辆私家车gps数据的实时路况系统，3分钟更新一次，通过网页可以获取，主要是针对意大利的摩托车道和一些主干道。

  道路匹配(经纬度和方向)->计算路由->计算路由道路上的时间，与我们的计算过程类似，但并没有给出具体实现，最后提供了几种估计未来路况的方法。

5. Real-time urban traffic monitoring with global positioning system-equipped vehicles

  使用point-to-curve道路匹配算法(做了改进)。使用eSMS（estimated space mean speed）并将其转换为更合理的路况量度

  1.道路匹配后的预处理：存储gps点，相同路段的点存在同一个数据结构中，对于每一个数据结构(对应一个路段),计算其第一个点到每个点的曲线距离，并作为gps点的一个属性存储。
  
  2.求eSMS：将某一路段上的点的速度曲线近似为2次方程。但计算路况时只取其平滑的部分(对加速度做限制)作为参考，并计算平均速度。最后对所有车的速度求eSMS。同一条道路有连续多个点时才能这样计算
  。
  
  3.将eSMS转化为一个更合理的smooth index(0,1之间，0表示拥堵，1表示畅通)

  实验：上海6000辆出租车。该方法将状态为空车的出租车数据丢弃，每4分钟算一次，没有考虑不同道路之间的路由。通过视频来人工判断路况，分5个等级，时间花费也较低

6. (1)Real-time Urban Traffic Sensing with GPS Equipped
Probe Vehicles (2) Scaling the Real-time Traffic Sensing with GPS Equipped Probe Vehicles

  在storm上部署实时路况探测，同样丢弃了空车的数据点，使用HMMM进行道路匹配，Fuzzy C-Means Clustering algorithm来去除一些不正常的行驶行为对路况的影响，将车辆探测到的速度分为2组，高速与低速，只有规模大的那一组会被采用。道路匹配是最耗时的部分

7. Traffic State Detection with Floating Car Data in Road Networks

  考虑了trafic center和出租车的信息交互过程。最小化信息交互次数，出租车在本地判断是否将该车在某一道路上的travel time（进入道路与离开道路的时间差）上传至中心(若travel time与本地已知的time差距大于某一阈值，则上传)。
出租车在离开道路后上传路况，中心需要对时间做修改，比如10：45上传出租车通过道路A需要30分钟，那么该路况同时也是10：15得路况。

  对路况做预测，并做动态导航
以预测为主，出租车的数据用于纠正历史信息，所以始终是有延迟的

# 5. 改进方向 {-}

  1. 计算当前的实时路况，不对点做分割，接受一个点处理一个点，另外有另一个进程进行延时处理，
进行轨迹切割(切割的时机可能有：1.长暂停，避免探测的路况与当前相隔太久而没有参考价值 2.行驶的道路发生了改变，道路改变后需要保留上一条道路的信息)，
计算更精准的路况(轨迹多，道路匹配更精确，借此导出的路由也更准确)，并根据该路况对实时路况进行反馈(如果道路相同，速度有出入，则对速度进行修正，如果道路不同，则尽量消除之前由该轨迹探测的路况对当前路况的影响)。

  2. 因为一条道路总的路况分为路口转向时间与行驶时间，路口信号的影响可以不用考虑，包含在转向延迟里。
  
  3. 对于无法正确匹配但本身没有异常的点单独存一份，用作以后挖掘新的道路。例子：(12788,2010-04-06 00:00:24)	lat:39.91935,lon:116.53758,head:357,speed:22.12,distance:0,min_matching_distance:-1.0, (12788,2010-04-06 00:01:24)	lat:39.93131,lon:116.53687,head:357,speed:22.12,distance:0,min_matching_distance:-1.0, (12788,2010-04-06 00:02:24)	lat:39.9396,lon:116.53815,head:72,speed:15.43,distance:0,min_matching_distance:-1.0, (12788,2010-04-06 00:03:19)

  4. 1200万定位有效的点中大约有350万处于重车的状态，对于空车的点，没必要全部丢弃，设定一个阈值，与
  道路速度的插值在一定范围内的可以采用，可以做实验分析。

  5. 
  
[在线的HMMM算法]: https://github.com/bmwcarit/barefoot


